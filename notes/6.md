* NGL, this chapter was a bit of a struggle at first. A Thing I came to realize doing this chapter is that by choosing to do this project in Rust, I end up having to fight Nystrom's pedagogy a little. There are times when he sketches or stubs things out without first fully explaining or elucidating them. That's perfectly valid teaching practice, but makes my task a little tricky. I ended up flipping forward and back through the text a few times until I was fully able to grasp everything he was doing.
* The obvious and immediate consequence of this is the top-level error handling. I'm no surer of how to do error reporting than I was for Chapter 4. Nystrom goes into error-handling and unwinding towards the end of the chapter but does it with Java exceptions, non-standardly (he `return`s instead of `throw`s in one situation, to let the caller pick whether to `throw` or not...I think?) He also introduces a `synchronize` method but doesn't really explain what it's supposed to do or how it works, so I...did my best.
* There was a brief "Oh, shit" moment when I got most of the way through and realized I had completely forgotten to deal with `Comment` and `Whitespace` tokens. After the initial panic subsided, I realized I could just pre-filter the tokens before parsing. Yes, it means iterating through the whole `Vec` twice, but it also means not having to worry about running into a `Comment` or `Whitespace` in literally every single function that matches a token and then having to advance `pos` etc. _No thank you._
  (This also argues against the value of the iterator-based approach (see below), since we're putting the whole thing in memory once already.)
* This chapter was the hardest I ended up rubbing up against the differences between Java and Rust's memory models. Nystrom implements a Recursive Descent Parser via a class with mutable state and (mutually) recursive methods. In my own amateurish Rust explorations, the combination of recursion and mutable state has always caused me to throw up my hands and stepping away.
  I initially tried to handle this with an iterator, like with the [scanner](../main/src/scanner.rs). It seemed the same, at first&mdash;like the scanner, Nystrom implements a class with a `List` and `current` index, then does a lot of index-fiddling and `.get(current)` to get the list elements. Here, the fiddling got the best of me. I'm not convinced it _couldn't_ be done with a `PeekMoreIterator`, but a) I couldn't figure it out, and b) I suspect it'd involve enough cursor-manipulation as to cut down on the benefits to the `PeekMoreIterator` approach.
  My next tack was a (too-)faithful adaptation of Nystrom's implementation, but I ran into the aforementioned recursion+mutability dragon. The problem is that you can only have one `&mut`, at a time, _even_ if it's `self`. In contrast, Java (and Python, and JS, and just about every other object-oriented language with automatic garbage collection) is basically passing the equivalent of `&mut self` willy-nilly. The "Rust way" to handle this kind of thing (from what I've gathered) is to narrow the scope of the `&mut` as much as possible[^1]. In this case, I realized that the `Vec<Token>` never needs to be mutable (we just index into it), and for whatever reason[^2], `&mut usize` doesn't cause problems the same way something like `&mut Vec<T>` does. Thus, the final implementation just threads `&Vec<Token>` and `&mut usize` through the various methods.
* Once I got the approach sorted out, everything actually went pretty smoothly. There was more boilerplate/duplication that I would have liked, much of it due once again to my decision to make `Token` an enum instead of a class with a `type` field, so I couldn't generalize `match` like Nystrom does, for instance. Still worth it, though!
* One of the many things I love about Rust's testing story is getting to put `mod test` in the same file as the code being tested. A consequence of this (I think??) is that there's no actual file-based way to filter tests. I'm so used to `pytest tests/test_foo.py`; there's no Rust equivalent. `cargo test` does however have pretty ergonomic filtering and no naming requirements (you use `#[test]` instead), so I just renamed all the tests to `<file>_<thing>` so I can just e.g. `cargo test parser` and call it a day.
  * I wrote a test for `synchronize` and just `#[ignore]`d it&mdash;I don't know what that function does! I'll fill the test in when I see `synchronize` used in the wild (hopefully in chapter 7).





[^1]: this applies to struct in general. In a language like Python, something like
    ```python
    class Foo:
        __init__(self, some_lst, some_dct, some_other_obj):
            self.lst = some_list
            self.dct = some_dct
            self.other_obj = some_other_obj
    ```
  is pretty standard practice. In Rust, this approach ends up bundling things together way too tightly. To ask the borrow-checker for permission to mutate _any_ of the fields in a struct, you have to ask for permission to mutate _all_ of them.

[^2]: I think it's related to [Copy](https://doc.rust-lang.org/stable/std/marker/trait.Copy.html) vs [Clone](https://doc.rust-lang.org/std/clone/trait.Clone.html), but I could not explain it in literally any more depth.
