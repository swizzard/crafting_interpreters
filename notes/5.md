This is where things get a little off the rails...Nystrom reaches for "metaprogramming" (actually, code generation) to cut down on boilerplate, which, as I understand it, is a long-storied and proud Java tradition. The Rust equivalent would be macros, which a) I'm not really comfortable with, and b) don't seem necessary. My entire `Expr` + pretty-printer implementations are 99 lines, including some Rust-specific boilerplate/shenanigans. Macros, schmacros.
* Nystrom liberally (ab)uses Java's `object` type/class. The Rust equivalent (I guess???) would be `dyn Any` (or in this case maybe `dyn Debug` or `dyn SomeTraitIMakeUpMyselfForJustThisPurposeWithNoRealPointOtherwise`) and _no thank you_. I checked `Token` and the only "literals" are `String`, `Number`, and `Nil`, so I just made a `Value` enum. It ends up being a little more typing (see [the tests](../main/src/expr.rs#L107)), but it's not onerous.
* Nystrom also goes with a Visitor pattern. I _think_ this (at least how he does it/what he uses it for) maps best onto [Traits](https://doc.rust-lang.org/book/ch10-02-traits.html), but again, I don't _really_ need it here. He goes with Visitor because he (auto)generates a bunch of separate subclasses for his `Expr` types, while I, once again, just used an enum. Writing a whole trait that I know will only ever be implemented by one thing is foolish, however...
* I _did_ do something Visitor-ish, kinda, with [`ExprPrinter`](../main/src/expr.rs#L42). The motivation behind that wasn't an homage to Nystrom, but rather a simple (somewhat hard-won) acknowledgement that passing a mutable string around through potentially recursive methods is a short-cut to Getting-Yelled-At-By-the-Compiler-Town. I scratched my head for a bit, then reached into the bag of patterns, past Visitor, and pulled out Builder, which ends up being invaluable due to the borrow checker. I'm not entirely convinced I actually need all the methods to return `InterpreterResult<Self>` instead of just `Self`, but I ended up adding a [`Fmt`](../main/src/errors.rs#L12) variant to my `InterpreterError` enum to painlessly handle `std::fmt::Error`, and besides, what's a few monads among friends?
* In all honesty, the initial reason I went with `InterpreterResult<Self>` was because I initially thought `build_binary` and `build_unary` were going to have to check whether the `Token` they were passed in _had_ a `lexeme` field. I reread the relevant part of Nystrom's code and thought back to last week when I was writing the `Token` enum, and realized I was mistaken&mdash;Nystrom has `lexeme` as a field on _all_ of his `Token`s, because he does it as class + tag, whereas I'm just using a regular rust enum. So I just went back and wrote `impl std::fmt::Display` for my `Token` enum, and just used that. It's just the pretty-printer; we don't have to care about syntactic correctness until the next chapter.
* Once again, Rust's testing absolutely rules. Nystrom farts out a throwaway `main` method to pretty-print one fairly-complex `Expr`; we can write actual tests to handle all the cases separately so we know it actually works.
