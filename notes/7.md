* Another chapter where the differences between Rust & Java made things interesting. I think on balance the Rust stuff I had to do was worth it, but there was a _lot_ of boilerplate involved.
* I added two new [error types](../main/src/errors.rs)&mdash;`Type` for type conversion errors, and `Unknown` because I needed _something_ to return in the case when the parser didn't return any errors but also didn't return a value.
* A good example of the mostly worth it boilerplate is all the [TryFrom](../main/src/expr.rs#L47) stuff in `expr.rs`. Rust does not do casting like Java does--you can't just `(type)value` and pray. Instead, you need to explicitly license conversions between types by writing either `From<T> for U` or `TryFrom<T> for U` (if conversions can fail) implementations. This is a bit of a pain, but the nice thing is that you automatically get `Into<U> for T` or `TryInto<U> for T` for free.
    * This led to me having to do a hacky thing with `Type` errors&mdash;I wanted line information to be displayed to the end user, but `try_from` doesn't take any other arguments, so there's no way of smuggling it in at conversion time. The solution I came up with was to add a `line: Option<usize>` field to the `Type` variant, and write an [`add_line_to_type_error`](../main/src/errors.rs#L42) method to set the line number when we have it. It's not great, but the [`cast_*`](../main/src/interpreter.rs#L92) helper functions I wrote make it a little less onerous.
* I still don't know what that `synchronize` function is supposed to do. Maybe I missed something?
